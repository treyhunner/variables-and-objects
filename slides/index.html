<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Variables and Objects</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Variables and Objects</h1>
          <p>
          <small><a href="https://treyhunner.com/" rel="author">Trey Hunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - TODO
            - Could you pause the recording or edit this out later?
            - ...
            - This is a *very* early and very rough version of what will eventually be a conference talk I'll be presenting in about a month
            - This will eventually be a 30 minute talk, but it should be a bit shorter tonight
            - This talk will include some teaching aimed for newer Python users and some pondering and some preaching aimed at experienced Python users
            - Some parts of this talk will eventually be cut
            - And some new parts will need to be added
            - Also the various pieces are a little bit less coherent than I plan for them to eventually be
            - I say all this to let you know that I *really* want your feedback on what you liked, what you felt didn't work, what seemed missing or lacking, and anything else you can think to tell me which might be helpful
          </aside>
        </section>

      </section>
      <section>
        <!-- section: mental models intro -->
        <!-- SECTION TIME: 1 minute -->

        <section data-background-color="#fff" data-transition="none">
          <a href="https://www.psy.ritsumei.ac.jp/akitaoka/saishin72e.html" target="_blank"><img src="marie-white-black.png" style="width: 1000px; margin: 0; border: 0; box-shadow: none; margin-bottom: 1px;"></a>
          <p>&copy; 2024 Akiyoshi Kitaoka, used with permission</p>
          <p><small><a href="https://www.psy.ritsumei.ac.jp/akitaoka/saishin72e.html" target="_blank">https://www.psy.ritsumei.ac.jp/akitaoka/saishin72e.html</a></small></p>
          <aside class="notes" data-markdown>
            - One of these faces is **white** and one is **black**
            - One has a dark background and one has a light background
            - And both faces are the same size
            - Or are they?
            - **TODO** *(show a ruler demonstrating the same size)*
            - ... yes, they are the same size
            - but they're also the same color
          </aside>
        </section>

        <section data-background-color="#fff" data-transition="none">
          <video width="1200" data-autoplay style="width: 1000px; margin: 0; margin-top: 0.5px; margin-right: 1px;" disablePictureInPicture>
            <source src="marie-white-black.webm" type="video/mp4">
          </video>
          <p class="fragment" style="background-color: #7c7c7c; font-family: monospace; color: #fff">#7c7c7c</p>
          <p><small><a href="https://www.psy.ritsumei.ac.jp/akitaoka/saishin72e.html" target="_blank">https://www.psy.ritsumei.ac.jp/akitaoka/saishin72e.html</a></small></p>
          <aside class="notes" data-markdown>
            - These faces are both **(CLICK)** a shade of gray that's *right* **in-between** white and black
            - This optical illusion happens because our brain is trying to **correct** for what it perceives as a difference in the **quality of light** around these two faces
            - Our brain is constantly **modeling** the world...
          </aside>
        </section>

        <section>
          <h1 class="fragment">Mental Models</h1>
          <blockquote style="box-shadow: none; font-size: 1.5em;" class="fragment">
            ‚ÄúAll models are wrong,<br>but some models are useful.‚Äù
            <nobr>&mdash; George E. P. Box</nobr>
          </blockquote>
          <aside class="notes" data-markdown>
            - Our brain's mental models **(CLICK)** help us understand the world around us and they're *usually* pretty great at doing so...
            - Every model of the world is flawed **(CLICK)** in some way
            - But even incorrect models can *still* be **useful**
          </aside>
        </section>

      </section>
      <section>
        <!-- section: Python mental models -->
        <!-- SECTION TIME: 3 minutes -->

        <section>
          <pre class="python"><code data-trim data-noescape style="font-size: 25px; line-height: 30px;">
>>> <span class="fragment" data-fragment-index=1>first = []
>>> </span><span class="fragment" data-fragment-index=3>second = first
>>> <span class="fragment" data-fragment-index=5>second.append(9)
>>> </span><span class="fragment" data-fragment-index=6>second
[9]
>>> </span><span class="fragment" data-fragment-index=7>first</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's **test your mental model** of Python's **variables**...
            - Here's the scenario we'll be working with...
            - We've assigned a variable, `first`, to an empty list **(CLICK)**
            - Then we assign the variable `second` to `first` **(CLICK)**
            - After that, we append `9` to `second` **(CLICK)**
            - Now `second` has `1` element within it **(CLICK)**
            - The question that I *don't* want you to answer right now... but which we'll be considering...
            - Is... **(CLICK)** "how many items are in `first`"?
            - ...
            - While we seek an answer to this question, let's **compare a few different mental models** of Python's variables to see how each one might explain this scenario
          </aside>
        </section>

        <section>
          <h2 class="fragment" data-fragment-index=1>Buckets</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape style="font-size: 25px; line-height: 30px;">
>>> <span class="fragment" data-fragment-index=2>first = []
>>> </span><span class="fragment" data-fragment-index=4>second = first
>>> <span class="fragment" data-fragment-index=6>second.append(9)
>>> </span><span class="fragment" data-fragment-index=7>second
[9]
>>> </span><span class="fragment" data-fragment-index=8>first</span><span class="fragment" data-fragment-index=9>
[9]</span></code></pre>
            <div style="display: grid; grid-auto-flow: column;">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 130" class="fragment" data-fragment-index=3 style="height: 250px;">
                <!-- Bucket -->
                <path d="M10 30 L110 30 L100 120 L20 120 Z" fill="none" stroke="black" stroke-width="2"/>

                <!-- Variable name -->
                <text x="60" y="20" font-size="16" text-anchor="middle">first</text>

                <!-- Empty list representation -->
                <text x="60" y="80" font-size="24" text-anchor="middle">[<tspan class="fragment" data-fragment-index=9 fill="#d00">9</tspan>]</text>
              </svg>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 130" class="fragment" data-fragment-index=5 style="height: 250px;">
                <!-- Bucket -->
                <path d="M10 30 L110 30 L100 120 L20 120 Z" fill="none" stroke="black" stroke-width="2"/>

                <!-- Variable name -->
                <text x="60" y="20" font-size="16" text-anchor="middle">second</text>

                <!-- Empty list representation -->
                <text x="60" y="80" font-size="24" text-anchor="middle">[<tspan class="fragment" data-fragment-index=6>9</tspan>]</text>
              </svg>
            </div>
          </div>
          <h2 style="color: #d00;" class="fragment" data-fragment-index=10>This mental model breaks down</h2>
          <aside class="notes" data-markdown>
            - First, let's try to mentally model variables as **(CLICK)** buckets that contain objects
            - If we assign a variable to an empty list **(CLICK)**, that variable **contains** that list **(CLICK)**
            - Then when we assign another variable to the first one, **(CLICK)** the list is **copied** into a new bucket **(CLICK)**
            - Let's say we then append `9` to that second list **(CLICK)**, which would **(CLICK)** mutate the second list
            - But the first list shouldn't change... **(CLICK)**
            - ... Except it *does* **(CLICK)** change!
            - This mental model **(CLICK)** doesn't work... at least not in Python
            - Variables in Python are *not* like **buckets that contain objects**
            - And assignment statements don't copy anything
            - Let's try another model...
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2 class="fragment" data-fragment-index=1>Sticky Notes</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape style="font-size: 25px; line-height: 30px;">
>>> <span class="fragment" data-fragment-index=2>first = []
>>> </span><span class="fragment" data-fragment-index=4>second = first
>>> <span class="fragment" data-fragment-index=6>second.append(9)
>>> </span><span class="fragment" data-fragment-index=7>second
[9]
>>> </span><span class="fragment" data-fragment-index=8>first
[9]
>>> </span>
            </code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 120" style="overflow: visible; width: 400px;" class="fragment" data-fragment-index=3>
                <!-- Empty list object -->
                <rect x="20" y="20" width="160" height="80" fill="white" stroke="black" stroke-width="2" rx="5" ry="5"/>
                <text x="100" y="70" font-size="24" text-anchor="middle" fill="black">[<tspan class="fragment" data-fragment-index=6>9</tspan>]</text>

                <!-- First sticky note -->
                <g transform="rotate(-15 30 30)">
                <rect x="10" y="0" width="60" height="60" fill="#FFFF88" stroke="#E6E600" stroke-width="1"/>
                <path d="M10 0 L70 0 L70 10 Q60 5 50 10 Q40 15 30 10 Q20 5 10 10 Z" fill="#FFFF66"/>
                <text x="40" y="35" font-size="12" text-anchor="middle" fill="black">first</text>
                </g>

                <!-- Second sticky note -->
                <g transform="rotate(15 170 30)" class="fragment" data-fragment-index=5>
                <rect x="130" y="0" width="60" height="60" fill="#FF9999" stroke="#FF6666" stroke-width="1"/>
                <path d="M130 0 L190 0 L190 10 Q180 5 170 10 Q160 15 150 10 Q140 5 130 10 Z" fill="#FF8888"/>
                <text x="160" y="35" font-size="12" text-anchor="middle" fill="black">second</text>
                </g>
              </svg>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - Let's mentally model variables as **(CLICK)** sticky notes on objects
            - When we assign a variable to an empty list **(CLICK)**, we attach that variable name to the object **(CLICK)**
            - Then when we assign **(CLICK)** another variable to the first one, we simply **(CLICK)** attach **another name** to the *same* object
            - So when we change **(CLICK)** that second list, the second one changes **(CLICK)** but the first one changes also **(CLICK)**... because there **is no** first and second list
            - it's all just *one* list!
            - This is the mental model that you'll find used in many books on Python and in many introductory Python courses
            - And this mental model works **pretty well**!
            - But it *also* has its limits
            - As an example, imagine that...
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <h2>Sticky Notes</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape style="font-size: 25px; line-height: 30px;">
>>> first = []
>>> second = first
>>> second.append(9)
>>> second
[9]
>>> first
[9]
>>> <span class="fragment" data-fragment-index=1>rows = [second]
>>> </span></code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 120" style="overflow: visible; width: 400px;">
                <!-- Empty list object -->
                <rect x="20" y="20" width="160" height="80" fill="white" stroke="black" stroke-width="2" rx="5" ry="5"/>
                <text x="100" y="70" font-size="24" text-anchor="middle" fill="black">[<tspan>9</tspan>]</text>

                <!-- First sticky note -->
                <g transform="rotate(-15 30 30)">
                <rect x="10" y="0" width="60" height="60" fill="#FFFF88" stroke="#E6E600" stroke-width="1"/>
                <path d="M10 0 L70 0 L70 10 Q60 5 50 10 Q40 15 30 10 Q20 5 10 10 Z" fill="#FFFF66"/>
                <text x="40" y="35" font-size="12" text-anchor="middle" fill="black">first</text>
                </g>

                <!-- Second sticky note -->
                <g transform="rotate(15 170 30)">
                <rect x="130" y="0" width="60" height="60" fill="#FF9999" stroke="#FF6666" stroke-width="1"/>
                <path d="M130 0 L190 0 L190 10 Q180 5 170 10 Q160 15 150 10 Q140 5 130 10 Z" fill="#FF8888"/>
                <text x="160" y="35" font-size="12" text-anchor="middle" fill="black">second</text>
                </g>
              </svg>

            </div>
          </div>
          <aside class="notes" data-markdown>
            - ...we put our list **(CLICK)** inside another list
            - What should our model look like now?
            - Well... what actually *happens* when we put one list inside another list?
            - We'll talk about that *later*
            - First, I'd like to introduce a *third* mental model...
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2 class="fragment" data-fragment-index=12 style="margin-left: 2em;">Pointers<span class="fragment" data-fragment-index=13>&nbsp;&nbsp;ü§î</span></h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=4>first = []
>>> </span><span class="fragment" data-fragment-index=6>second = first
>>> <span class="fragment" data-fragment-index=8>second.append(9)
>>> </span><span class="fragment" data-fragment-index=10>second
[9]
>>> </span><span class="fragment" data-fragment-index=11>first
[9]
>>> </span><span style="visibility: hidden;">rows = [second]
>>> </span>
            </code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" width="500" height="299" viewBox="0 0 421 251">
                <g class="fragment" data-fragment-index=3>
                <path d="M 200 23 L 200 0 L 420 0 L 420 23" fill="#dae8fc" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 200 250 L 420 250 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <text x="309.5" y="15" fill="#000" text-anchor="middle" font-size="12px">Object Land</text>
                </g>
                <g class="fragment" data-fragment-index=2>
                <path d="M 0 23 L 0 0 L 160 0 L 160 23" fill="#e1d5e7" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 0 250 L 160 250 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <text x="79.5" y="15" fill="#000" text-anchor="middle" font-size="13px">Variable Land</text>
                </g>
                <g class="fragment" data-fragment-index=5>
                  <path d="M 250.5 70 L 227.5 70 L 227.5 120 L 250.5 120" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 307.5 70 L 307.5 120 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="238.5" y="98.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,239,95)">list</text>

                  <rect x="20" y="39" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="67" fill="#000" font-size="13px" text-anchor="middle">first</text>
                  <path d="M 140 65 L 221.26 81.25" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.4 82.28 L 218.85 84.34 L 221.26 81.25 L 220.23 77.48 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g class="fragment" data-fragment-index=7>
                  <rect x="20" y="109" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="137" fill="#000" font-size="13px" text-anchor="middle">second</text>
                  <path d="M 140 135 L 221.42 109.41" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.43 107.84 L 220.8 113.27 L 221.42 109.41 L 218.71 106.6 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g class="fragment" data-fragment-index=5>
                  <text x="274" y="98.5" fill="#00f" font-size="13px" text-anchor="middle" class="fragment fade-out" data-fragment-index=9>[]</text>
                </g>
                <g class="fragment" data-fragment-index=9>
                  <text x="274" y="98.5" fill="#00f" font-size="13px" text-anchor="middle">[9]</text>
                </g>
              </svg>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - In this third model, we'll think of variables as living in **(CLICK)** variable land and objects as living in **(CLICK)** object land
            - When we assign a variable **(CLICK)** we draw an arrow  **(CLICK)** from the variable to the object
            - Then when we assign **(CLICK)** another variable to the first one, we draw another arrow **(CLICK)** from the second variable to the same object
            - So if we **(CLICK)** modify the second list **(CLICK)**...
            - The second list changes **(CLICK)** and so does the first **(CLICK)** because *they're the same list*
            - I call this mental model "pointers" **(CLICK)** because it looks like variables *point* to objects
            - ...
            - If you're thinking **(CLICK)** the word "pointer" might be a problem, stay with me.
            - I will get to that thought later
          </aside>
        </section>

      </section>
      <section>
        <!-- section: change -->
        <!-- SECTION TIME: 4 minutes -->

        <section data-transition="slide-in none-out">
          <h1>
            <span class="fragment fade-out" data-fragment-index=6
            ><span class="fragment" data-fragment-index=1>Ch-</span
            ><span class="fragment" data-fragment-index=2>ch-</span
            ><span class="fragment" data-fragment-index=3>ch-</span
            ></span><span class="fragment" data-fragment-index=4>chang</span
            ><span class="fragment" data-fragment-index=5>e<span
              class="fragment fade-out" data-fragment-index=6>s</span></span>
          </h1>
          <div class="fragment fade-out" data-fragment-index=6 style="margin: 0 auto; width: 800px; display: grid; grid-template-columns: repeat(12, 1fr); grid-gap: 10px;">
            <img src="david-bowie/david-bowie.jpg" class="fragment no-style" data-fragment-index=1 style="grid-column: span 4">
            <img src="david-bowie/man-of-words.jpg" class="fragment no-style" data-fragment-index=2 style="grid-column: span 4">
            <img src="david-bowie/hunky-dory-outtake.jpg" class="fragment no-style" data-fragment-index=3 style="grid-column: span 4">
            <img src="david-bowie/pin-ups.jpg" class="fragment no-style" data-fragment-index=4 style="grid-column: 3 / span 4">
            <img src="david-bowie/heroes.jpg" class="fragment no-style" data-fragment-index=5 style="grid-column: span 4">
          </div>
          <aside class="notes" data-markdown>
            - But before we talk about the word "pointer"...
            - **(CLICK)** *(ch)*
            - **(CLICK)** *(ch)*
            - **(CLICK)** *(ch)*
            - **(CLICK)** *(chang)*
            - **(CLICK)** *(es)*
            - ...
            - Let's talk about the word "change"...
            - In Python, **(CLICK)** this word can be a problem
          </aside>
        </section>

        <section>
          <p class="fragment" data-fragment-index=2>&ldquo;when I <span class="fragment bold" data-fragment-index=7>change</span> <code>first</code>, it doesn't always <span class="fragment bold" data-fragment-index=7>change</span> <code>second</code>&rdquo;</p>
          <pre class="python fragment" data-fragment-index=1 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> first = [2, 1, 3, 4]
>>> second = first
>>> <span class="fragment" data-fragment-index=3>first.append(7)
>>> </span><span class="fragment" data-fragment-index=4>second
[2, 1, 3, 4, 7]
>>> </span><span class="fragment" data-fragment-index=5>first = [100, 200, 300]
>>> </span><span class="fragment" data-fragment-index=6>second
[2, 1, 3, 4, 7]
>>> </span>
          </code></pre>
          <aside class="notes" data-markdown>
            - New Python users often tell me that they've **(CLICK)** assigned two variables (`first` and `second`) to the same value and then they'll say **(CLICK)** "when I change `first`, it **doesn't *always* change `second`**"
            - When I ask what they mean, they'll show me something like this...
            - "here I changed first" **(CLICK)** "and second changed" **(CLICK)**
            - But "*here* when I change first" **(CLICK)**... "second doesn't change" **(CLICK)**
            - Why?
            - The word "change" **(CLICK)** is the problem here.
            - "change" is accidentally playing two different roles
          </aside>
        </section>

        <section>
          <h2 class="fragment" data-fragment-index=1>&ldquo;bianually&rdquo;</h2>
          <p class="fragment" data-fragment-index=2>twice a year or once every two years</p>
          <h2 class="fragment" data-fragment-index=3>&ldquo;4 ounces&rdquo;</h2>
          <p class="fragment" data-fragment-index=4>a half cup or a quarter pound</p>
          <h2 class="fragment" data-fragment-index=5>&ldquo;change&rdquo;</h2>
          <p class="fragment" data-fragment-index=6>assigning a variable or mutating a value</p>
          <aside class="notes" data-markdown>
            - It's like the word biannually **(CLICK)**: do we mean **(CLICK)** twice a year or once every two years?
            - Or ounces **(CLICK)**... are we talking **(CLICK)** volume or weight: half a cup or a quarter pound?
            - The word change **(CLICK)** has a similar problem
            - There are *two different* **(CLICK)** types of "change" in Python
            - **Assignments** change variables and **mutations change objects**
          </aside>
        </section>

        <section>
          <p class="fragment" data-fragment-index=5>&ldquo;when I reassign <code>first</code>, it doesn't affect <code>second</code>&rdquo;</p>
          <p class="fragment" data-fragment-index=3>&ldquo;when I mutate the list, both <code>first</code> and <code>second</code> change&rdquo;</p>
          <p class="fragment strike" data-fragment-index=1>&ldquo;when I change <code>first</code>, it doesn't always change <code>second</code>&rdquo;</p>
          <pre class="python" style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> first = [2, 1, 3, 4]
>>> second = first
>>> <span class="fragment" data-fragment-index=3>first.append(7)
>>> </span><span class="fragment" data-fragment-index=4>second
[2, 1, 3, 4, 7]
>>> </span><span class="fragment" data-fragment-index=5>first = [100, 200, 300]
>>> </span><span class="fragment" data-fragment-index=6>second
[2, 1, 3, 4, 7]
>>></span>
          </code></pre>
          <h2 class="fragment" data-fragment-index=2>&ldquo;Explicit is better than implicit&rdquo;</h2>
          <aside class="notes" data-markdown>
            - So instead of using the word "change" **(CLICK)** I encourage folks learning with me to be more explicit **(CLICK)**
            - When we **(CLICK)** mutate the object that `first` points to, if `second` **points to the same object**, accessing `second` **(CLICK)** will show the same *changed* object
            - But if we **(CLICK)** reassign first, we changed the object that the `first` variable points to
            - ... But that *doesn't* change the `second` variable at all... **(CLICK)**
            - `second` still points to the same object as before
            - `first` just points to a different object now
            - The word change can be **ambiguous** in Python... and ambiguity can reinforce **fuzzy and incorrect mental models**
            - Just to drive home these two types of change, let's try to use that third mental model again...
          </aside>
        </section>

        <section>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape>
>>> first = [2, 1, 3, 4]
>>> second = first
>>> <span class="fragment" data-fragment-index=1>first.append(7)
>>> </span><span class="fragment" data-fragment-index=3>second
[2, 1, 3, 4, 7]
>>> </span><span class="fragment" data-fragment-index=5>first = [100, 200, 300]
>>> </span><span class="fragment" data-fragment-index=7>second
[2, 1, 3, 4, 7]
>>>
            </span></code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" width="500" height="299" viewBox="0 0 421 251">
                <g>
                <path d="M 200 23 L 200 0 L 420 0 L 420 23" fill="#dae8fc" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 200 250 L 420 250 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <text x="309.5" y="15" fill="#000" text-anchor="middle" font-size="12px">Object Land</text>
                </g>
                <g>
                <path d="M 0 23 L 0 0 L 160 0 L 160 23" fill="#e1d5e7" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 0 250 L 160 250 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <text x="79.5" y="15" fill="#000" text-anchor="middle" font-size="13px">Variable Land</text>
                </g>
                <g>
                  <path d="M 250.5 70 L 227.5 70 L 227.5 120 L 250.5 120" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 387.5 70 L 387.5 120 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="238.5" y="98.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,239,95)">list</text>

                  <rect x="20" y="39" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="67" fill="#000" font-size="13px" text-anchor="middle">second</text>
                  <path d="M 140 65 L 221.26 81.25" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.4 82.28 L 218.85 84.34 L 221.26 81.25 L 220.23 77.48 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g>
                  <rect x="20" y="109" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="137" fill="#000" font-size="13px" text-anchor="middle">first</text>
                  <path d="M 140 135 L 221.42 109.41" fill="none" stroke="#000" stroke-miterlimit="10" class="fragment fade-out" data-fragment-index=6 />
                  <path d="M 226.43 107.84 L 220.8 113.27 L 221.42 109.41 L 218.71 106.6 Z" fill="#000" stroke="#000" stroke-miterlimit="10" class="fragment fade-out" data-fragment-index=6 />
                </g>
                <g>
                  <text x="319" y="98.5" fill="#00f" font-size="13px" text-anchor="middle" class="fragment fade-out" data-fragment-index=2>[2, 1, 3, 4]</text>
                  <text x="319" y="98.5" fill="#00f" font-size="13px" text-anchor="middle" class="fragment" data-fragment-index=2>[2, 1, 3, 4, 7]</text>
                </g>
                <g class="fragment" data-fragment-index=6>
                  <path d="M 140 135 L 213.63 201.5" fill="none" stroke="#000" stroke-miterlimit="10"/>
<path d="M 218.88 205 L 211.88 208.5 L 213.63 205 L 211.88 201.5 Z" 
      fill="#000" 
      stroke="#000" 
      stroke-miterlimit="10"
      transform="rotate(45, 218.88, 205)"/>

                  <path d="M 243 180 L 220 180 L 220 230 L 243 230" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 243 180 L 375 180 L 375 230 L 243 230" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 243 180 L 243 230" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="231" y="208.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,231.5,205)">list</text>
                  <text x="307" y="208.5" fill="#00f" font-size="13px" text-anchor="middle">[100, 200, 300]</text>
                </g>
              </svg>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - So... we've assigned `second` to `first` which means both variables now point to **the same** 4-item list
            - When we **append** to `first` **(CLICK)**, the list changes **(CLICK)**
            - When we look at `second`, **(CLICK)** we'll see that it changed because it **points to the same list**
            - But if we **reassign** `first`, **(CLICK)** we're **pointing that variable** to a *new* list **(CLICK)**
            - Which means `second` is unchanged **(CLICK)**
            - The `second` variable still points to the **original list**, which hasn't been touched
            - This is why the word "change" is ambiguous: mutations change objects and assignments change **which object** a *variable* points to
          </aside>
        </section>

        <section>
          <p class="fragment" data-fragment-index=1 style="margin-top: -1em;"><span class="fragment fade-out" data-fragment-index=2>Remember: variables point to objects</span></p>
          <h2 class="fragment" data-fragment-index=2>The 2 Types of Change</h2>
          <ul style="list-style-type: none; margin-left: -2em;">
            <li class="fragment" data-fragment-index=3><strong>Mutations</strong> change an object</li>
            <li class="fragment" data-fragment-index=4><strong>Assignments</strong> change a variable</li>
          </ul>
          <aside class="notes" data-markdown>
            - So... **(click)** variables in Python do not *contain* objects, they *point* to them
            - Because of this indirection between variables and objects, **(click)** there are 2 distinct types of "change"
            - A **(CLICK)** mutation changes an object
            - While an **(CLICK)** assignment changes a variable... specifically which object that variable is pointing to
          </aside>
        </section>

      </section>
      <section>
        <!-- section: identity -->
        <!-- SECTION TIME: TODO -->

        <section>
          <h1 class="fragment">2 types of</h1>
          <h1 class="fragment">&ldquo;are they the same?&rdquo;</h1>
          <pre class="python fragment" data-fragment-index=1 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=3>first == second
True
>>> </span><span class="fragment" data-fragment-index=4>first is second
True</span></code></pre>
          <aside class="notes" data-markdown>
            - TODO visuals
            - In Python, we have two different types of "change"...
            - But we also have **(CLICK)** two different ways to ask the question...
            - **(CLICK)** "are they the same?"
            - We have the **(CLICK)** double equals operator (`==`) for **(CLICK)** *equality*
            - And we have the **(CLICK)** `is` operator for **(CLICK)** *identity*
            - You can think of equality and identity as asking about model numbers and serial numbers.
          </aside>
        </section>

        <section>
          <h1 class="fragment">TODO</h1>
          <aside class="notes" data-markdown>
            - TODO visuals
            - If I'm in the market to buy a washing machine, I might ask "what's the model number?"
            - I'm hoping to look up reviews for what *should* equivalent devices.
            - But if I need to call customer support to report an issue, I might give them the serial number for the device.
            - The serial number uniquely identifies the device.
            - Equality checks are a like a comparison of model numbers... they ask whether two objects represent the same thing.
            = Identity checks are like a comparison of serial numbers... they ask whether two objects are identical... meaning they aren't even two objects... they are *the same exact object*
            - Though really...
          </aside>
        </section>

        <section>
          <h1 class="fragment">TODO</h1>
          <pre class="python fragment" data-fragment-index=1 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=3>first == second
True
>>> </span><span class="fragment" data-fragment-index=4>first is second
True</span></code></pre>
          <aside class="notes" data-markdown>
            - identity isn't *about objects* at all... it's actually a way to ask whether two references are referring to *exactly* the same object.
            - If we have two variables, `first`, and `second`, and we ask whether they are *equal*, we're asking whether they have the same value... this asks the *objects* whether they represent the same thing
            - If we ask whether these variables are *identical* we're asking whether they both point to the same object... this doesn't ask any question of the object itself. This is a more low level and fundamental question and there's no way for objects to control the behavior of the `is` operator.
          </aside>
        </section>

        <section>
          <h1 class="fragment">TODO</h1>
          <pre class="python fragment" data-fragment-index=1 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=3>first == second
True
>>> </span><span class="fragment" data-fragment-index=4>first is second
True</span></code></pre>
          <aside class="notes" data-markdown>
        - The `is` operator is *very* rarely used outside of checking whether an object is identical to `None`, `True`, or `False`.
        - Unless you *actually* care whether two objects are the exact same object, when asking "are they the same?" you want the `==` operator.
          </aside>
        </section>

      </section>
      <section>
        <!-- section: containment -->
        <!-- SECTION TIME: 7 minutes -->

        <section>
          <h1 class="fragment" data-fragment-index=2>Objects</h1>
          <h2 class="fragment current-visible" data-fragment-index=1>Variables</h2>
          <aside class="notes" data-markdown>
            - We have been talking mostly about **(CLICK)** variables and how they work
            - We haven't really discussed how **(CLICK)** objects work
            - Let's start inspecting objects, by playing with Python's data structures
          </aside>
        </section>

        <section>
          <h2 style="margin-top: -2em;" class="fragment current-visible" data-fragment-index=12>&ldquo;Change&rdquo;</h2>
          <h2 class="fragment" data-fragment-index=13>&ldquo;Contains&rdquo;</h2>
          <pre class="python"><code data-trim data-noescape style="font-size: 25px; line-height: 30px;">
>>> <span class="fragment" data-fragment-index=1>row = [0, 0, 0]
>>> </span><span class="fragment" data-fragment-index=3>boat = [row, row, row]
>>> </span><span class="fragment" data-fragment-index=5>boat</span><span class="fragment" data-fragment-index=6>
[[0, 0, 0], <span class="fragment bold-current" data-fragment-index=9>[0, 0, 0]</span>, [0, 0, 0]]
>>> </span><span class="fragment" data-fragment-index=7>boat[1][1] = 1
>>> </span><span class="fragment" data-fragment-index=8>boat</span><span class="fragment" data-fragment-index=10>
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
>>> </span><span class="fragment" data-fragment-index=11>row
[0, 1, 0]</span></code></pre>
          <aside class="notes" data-markdown>
            - Let's make a 3-item list and call it `row` **(CLICK)**
            - Then we'll make another list, called `boat`, that contains `row`, `row`, and `row` **(CLICK)**
            - So the `boat` list **(CLICK)** contains **(CLICK)** 3 lists which each containing `0` 3 times
            - If we assign to index `1` within index `1` in the `boat` list... **(CLICK)**
            - What changes? **(CLICK)**...
            - Index `1` is the middle item in `boat`, **(CLICK)** which is a list...
            - And index `1` in that sub-list is its middle item...
            - So we changed the middle item in the middle list... **(CLICK)**
            - ... sort of
            - It looks like we changed a bit more than that
            - Every sub-list within `boat` changed
            - In fact, **(CLICK)** even `row` changed
            - I've been using the word **(CLICK)** "change" here
            - ... which, as we discussed, can be a tricky word
            - But I also used... the word "contains" **(CLICK)**
            - The word "contains" can *also* cause confusion
          </aside>
        </section>

        <section>
          <h2>Sticky Notes</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape style="font-size: 25px; line-height: 30px;">
>>> first = []
>>> second = first
>>> second.append(9)
>>> second
[9]
>>> first
[9]
>>> <span class="fragment" data-fragment-index=1>rows = [second]
>>> </span><span class="fragment" data-fragment-index=3>lists = rows</span></code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 120" style="overflow: visible; width: 400px;">
                <!-- Empty list object -->
                <rect x="20" y="20" width="160" height="80" fill="white" stroke="black" stroke-width="2" rx="5" ry="5"/>
                <text x="100" y="70" font-size="24" text-anchor="middle" fill="black">[<tspan>9</tspan>]</text>

                <!-- First sticky note -->
                <g transform="rotate(-15 30 30)">
                <rect x="10" y="0" width="60" height="60" fill="#FFFF88" stroke="#E6E600" stroke-width="1"/>
                <path d="M10 0 L70 0 L70 10 Q60 5 50 10 Q40 15 30 10 Q20 5 10 10 Z" fill="#FFFF66"/>
                <text x="40" y="35" font-size="12" text-anchor="middle" fill="black">first</text>
                </g>

                <!-- Second sticky note -->
                <g transform="rotate(15 170 30)">
                <rect x="130" y="0" width="60" height="60" fill="#FF9999" stroke="#FF6666" stroke-width="1"/>
                <path d="M130 0 L190 0 L190 10 Q180 5 170 10 Q160 15 150 10 Q140 5 130 10 Z" fill="#FF8888"/>
                <text x="160" y="35" font-size="12" text-anchor="middle" fill="black">second</text>
                </g>

                <!-- Third sticky note -->
                <g transform="rotate(-15 30 90)" class="fragment" data-fragment-index=2>
                <rect x="10" y="60" width="60" height="60" fill="#88FF88" stroke="#66E666" stroke-width="1"/>
                <path d="M10 60 L70 60 L70 70 Q60 65 50 70 Q40 75 30 70 Q20 65 10 70 Z" fill="#88FF66"/>
                <text x="40" y="95" font-size="12" text-anchor="middle" fill="black">rows[0]</text>
                </g>

                <!-- Fourth sticky note -->
                <g transform="rotate(5 170 80)" class="fragment" data-fragment-index=4>
                <rect x="150" y="60" width="60" height="60" fill="#9966FF" stroke="#6666FF" stroke-width="1"/>
                <path d="M150 60 L210 60 L210 70 Q200 65 190 70 Q180 75 170 70 Q160 65 150 70 Z" fill="#8888FF"/>
                <text x="180" y="95" font-size="12" text-anchor="middle" fill="black">lists[0]</text>
                </g>
              </svg>

            </div>
          </div>
          <aside class="notes" data-markdown>
            - Let's revisit our mental model of variables as sticky notes...
            - We were about to ask "what should happen" we put our `second` list inside another list...
            - Should we **add another sticky note** that says **(CLICK)** which list it's in and which index it's at?
            - Also... what if we point **(CLICK)** another variable to that new outer list?
            - Would we need to add yet *another* note with another name and another index? **(CLICK)**
            - This *does* work, but it seems a bit complicated
            - This sticky note mental model works *well* for explaining how **variables** in Python work...
            - But it doesn't work well for explaining how **objects** work
            - Let's take a look at how our pointers mental model works in this scenario...
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2>Pointers</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=4>first = []
>>> </span><span class="fragment" data-fragment-index=6>second = first
>>> <span class="fragment" data-fragment-index=8>second.append(9)
>>> </span><span class="fragment" data-fragment-index=10>second
[9]
>>> </span><span class="fragment" data-fragment-index=11>first
[9]
>>> </span><span style="visibility: hidden;">rows = [second]
>>> </span>
            </code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" width="500" height="299" viewBox="0 0 421 251">
                <g>
                <path d="M 200 23 L 200 0 L 420 0 L 420 23" fill="#dae8fc" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 200 250 L 420 250 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <text x="309.5" y="15" fill="#000" text-anchor="middle" font-size="12px">Object Land</text>
                </g>
                <g>
                <path d="M 0 23 L 0 0 L 160 0 L 160 23" fill="#e1d5e7" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 0 250 L 160 250 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <text x="79.5" y="15" fill="#000" text-anchor="middle" font-size="13px">Variable Land</text>
                </g>
                <g class="fragment" data-fragment-index=5>
                  <path d="M 250.5 70 L 227.5 70 L 227.5 120 L 250.5 120" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 307.5 70 L 307.5 120 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="238.5" y="98.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,239,95)">list</text>

                  <rect x="20" y="39" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="67" fill="#000" font-size="13px" text-anchor="middle">first</text>
                  <path d="M 140 65 L 221.26 81.25" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.4 82.28 L 218.85 84.34 L 221.26 81.25 L 220.23 77.48 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g class="fragment" data-fragment-index=7>
                  <rect x="20" y="109" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="137" fill="#000" font-size="13px" text-anchor="middle">second</text>
                  <path d="M 140 135 L 221.42 109.41" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.43 107.84 L 220.8 113.27 L 221.42 109.41 L 218.71 106.6 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g class="fragment" data-fragment-index=9>
                  <path d="M 353 40 L 330 40 L 330 90 L 353 90" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 353 40 L 390 40 L 390 90 L 353 90" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 353 40 L 353 90" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="341" y="68.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,341.5,65)">int</text>
                  <text x="370" y="68" fill="#000" font-size="13px" text-anchor="middle" class="fragment bold-current" data-fragment-index=13>9</text>

                  <path d="M 287.5 95 L 324.8 68.67" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 329.09 65.64 L 325.39 72.54 L 324.8 68.67 L 321.35 66.82 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>

                  <rect x="262.5" y="85" width="25" height="20" fill="none" stroke="#000"/>
                  <text x="274" y="98.5" fill="#00f" font-size="13px" text-anchor="middle" class="fragment bold-current" data-fragment-index=12>0</text>
                </g>
                <g style="visibility: hidden;">
                  <rect x="20" y="179" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="207" fill="#000" font-size="13px" text-anchor="middle">rows</text>
                  <path d="M 140 205 L 213.63 205" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 218.88 205 L 211.88 208.5 L 213.63 205 L 211.88 201.5 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 267.5 195 L 285.86 126.15" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 287.21 121.08 L 288.79 128.75 L 285.86 126.15 L 282.03 126.94 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>

                  <path d="M 243 180 L 220 180 L 220 230 L 243 230" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 243 180 L 300 180 L 300 230 L 243 230" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 243 180 L 243 230" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="231" y="208.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,231.5,205)">list</text>
                  <rect x="255" y="194" width="25" height="20" fill="none" stroke="#000"/>
                  <text x="267" y="208.5" fill="#00f" font-size="13px" text-anchor="middle">0</text>
                </g>
              </svg>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - When we assign the `first` variable **(CLICK)** to an empty list, we draw an arrow **(CLICK)** from the variable to the object
            - Then when we assign **(CLICK)** another variable to the first one, we draw another arrow **(CLICK)** from the second variable to the same object
            - So if we **(CLICK)** modify the second list **(CLICK)**...
            - The second list changes **(CLICK)** and so does the first **(CLICK)** because *they're the same list*
            - But wait... our diagram before didn't look quite like this...
            - This time, our list has an **arrow pointing to an integer**... why is that?
            - Well, **variables don't contain objects**, but objects *also* don't contain objects
            - Objects can only *point* to objects, so the list's index `0` **(CLICK)** points to the integer `9` **(CLICK)**
            - That's also why...
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <h2>Pointers</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape>
>>> first = []
>>> second = first
>>> second.append(9)
>>> second
[9]
>>> first
[9]
>>> <span class="fragment" data-fragment-index=9>rows = [second]
>>> 
            </span></code></pre>
            <div>
              <svg xmlns="http://www.w3.org/2000/svg" width="500" height="299" viewBox="0 0 421 251">
                <g>
                <path d="M 200 23 L 200 0 L 420 0 L 420 23" fill="#dae8fc" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 200 250 L 420 250 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <path d="M 200 23 L 420 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
                <text x="309.5" y="15" fill="#000" text-anchor="middle" font-size="12px">Object Land</text>
                </g>
                <g>
                <path d="M 0 23 L 0 0 L 160 0 L 160 23" fill="#e1d5e7" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 0 250 L 160 250 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <path d="M 0 23 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
                <text x="79.5" y="15" fill="#000" text-anchor="middle" font-size="13px">Variable Land</text>
                </g>
                <g>
                  <path d="M 250.5 70 L 227.5 70 L 227.5 120 L 250.5 120" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 307.5 70 L 307.5 120 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 250.5 70 L 250.5 120" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="238.5" y="98.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,239,95)">list</text>

                  <rect x="20" y="39" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="67" fill="#000" font-size="13px" text-anchor="middle">first</text>
                  <path d="M 140 65 L 221.26 81.25" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.4 82.28 L 218.85 84.34 L 221.26 81.25 L 220.23 77.48 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g>
                  <rect x="20" y="109" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="137" fill="#000" font-size="13px" text-anchor="middle">second</text>
                  <path d="M 140 135 L 221.42 109.41" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 226.43 107.84 L 220.8 113.27 L 221.42 109.41 L 218.71 106.6 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                </g>
                <g>
                  <path d="M 353 40 L 330 40 L 330 90 L 353 90" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 353 40 L 390 40 L 390 90 L 353 90" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 353 40 L 353 90" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="341" y="68.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,341.5,65)">int</text>
                  <text x="370" y="68" fill="#000" font-size="13px" text-anchor="middle">9</text>

                  <path d="M 287.5 95 L 324.8 68.67" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 329.09 65.64 L 325.39 72.54 L 324.8 68.67 L 321.35 66.82 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>

                  <rect x="262.5" y="85" width="25" height="20" fill="none" stroke="#000"/>
                  <text x="274" y="98.5" fill="#00f" font-size="13px" text-anchor="middle">0</text>
                </g>
                <g class="fragment" data-fragment-index=10>
                  <rect x="20" y="179" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
                  <text x="79" y="207" fill="#000" font-size="13px" text-anchor="middle">rows</text>
                  <path d="M 140 205 L 213.63 205" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 218.88 205 L 211.88 208.5 L 213.63 205 L 211.88 201.5 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 267.5 195 L 285.86 126.15" fill="none" stroke="#000" stroke-miterlimit="10"/>
                  <path d="M 287.21 121.08 L 288.79 128.75 L 285.86 126.15 L 282.03 126.94 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>

                  <path d="M 243 180 L 220 180 L 220 230 L 243 230" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 243 180 L 300 180 L 300 230 L 243 230" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <path d="M 243 180 L 243 230" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
                  <text x="231" y="208.5" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,231.5,205)">list</text>
                  <rect x="255" y="194" width="25" height="20" fill="none" stroke="#000"/>
                  <text x="267" y="208.5" fill="#00f" font-size="13px" text-anchor="middle">0</text>
                </g>
              </svg>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - ... if we **(CLICK)** put our list inside another list, we'll be **(CLICK)** pointing one of the indexes in that **new list** to *our* **existing** list
            - Variables **can point** to objects and objects *can point* to **other objects**.
            - But nothing **ever** points to variables.
            - Variables are just a name that refers to an object
            - ...
            - This "pointers" mental model *is* a bit more **complex** than the sticky note model, but it **stretches** a bit further
            - The **indirection** between variables and objects **is tricky**, but it also makes it easier to understand how **data structures** work.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> runtimes = {'v1': [38, 47, 52], 'v2.5': [27, 12, 23]}
>>> <span class="fragment">v1_runtimes = runtimes['v1']
>>> </span><span class="fragment">v1_runtimes.pop()
52
>>> <span class="fragment">runtimes
{'v1': [38, 47], 'v2.5': [27, 12, 23]}
>>> </span><span class="fragment">v1_runtimes = runtimes['v1'].copy()
>>> </span><span class="fragment">v1_runtimes = list(runtimes['v1'])</span></code></pre>
          <aside class="notes" data-markdown>
            - So we may talk about lists-of-lists or dictionaries-of-lists...
            - But this dictionary doesn't *actually* contain lists... it contains references to lists
            - This is an important thing to acknowledge *if* those values might be used **(CLICK)** anywhere else in our program
            - Because if we change the values in our dictionary or **(CLICK)** if those values change somewhere else, we *might* be unhappy **(CLICK)**
            - We could avoid this problem by copying those objects using **(CLICK)** the `list` class's `copy` method or by calling **(CLICK)** the `list` constructor to make a new list out of an old one
          </aside>
        </section>

        <section>
          <h1 class="fragment">Containment</h1>
          <h2 class="fragment">... is a lie</h2>
          <aside class="notes" data-markdown>
            - In Python, "containment" **(click)** is a slightly misleading term **(click)**
            - Data structures don't actually contain data
            - Data structures contain references to data
            - But this...
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=2>class TodoList:
...     def __init__(self, tasks):
...         self.tasks = tasks
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> </span><span class="fragment" data-fragment-index=3>default_todos = ["Reflect on last week"]
>>> </span><span class="fragment fade-out" data-fragment-index=10><span class="fragment" data-fragment-index=4>mon = TodoList(default_todos)
>>> </span><span class="fragment" data-fragment-index=5>tue = TodoList(default_todos)
>>> </span><span class="fragment" data-fragment-index=6>mon.add_task("Work on talk")
>>> </span><span class="fragment" data-fragment-index=7>mon.tasks
['Reflect on last week', 'Work on talk']
>>> </span><span class="fragment" data-fragment-index=8>tue.tasks</span><span class="fragment" data-fragment-index=9>
['Reflect on last week', 'Work on talk']</span></span>
<br>
          </code></pre>
          <aside class="notes" data-markdown>
            - ...isn't just about data structures... this is about pretty much *every object in Python* **(CLICK)**
            - Let's say we make *our own* objects using a class **(CLICK)**
            - This class accepts a list and stores that list as an attribute on our class instances
            - If we pass **(CLICK)** the same list **(CLICK)** into this class twice... **(CLICK)**
            - We'll end up with two class instances that have the same attribute
            - But what if we mutate the `tasks` list **(CLICK)** for one of those two objects? **(CLICK)**
            - Will that affect **(CLICK)** the *other* instance?
            - ...
            - It will! **(CLICK)**
            - Attributes, like variables, don't *contain* objects... they *point* to objects
            - This might seem like a *really* big issue... **(CLICK)**
            - But this problem has a pretty common solution
          </aside>
        </section>

        <section data-transition="none-in none-out">
          <pre class="python"><code data-trim data-noescape>
>>> <span>class TodoList:
...     def __init__(self, tasks):
...         self.tasks = <span class="fragment bold-current">list(tasks)</span>
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> default_todos = ["Reflect on last week"]
>>> </span><span class="fragment">mon = TodoList(default_todos)
>>> tue = TodoList(default_todos)
>>> </span><span class="fragment">mon.add_task("Work on talk")
>>> </span><span class="fragment">mon.tasks
['Reflect on last week', 'Work on talk']
>>> </span><span class="fragment">tue.tasks
[]
>>> </span><span class="fragment">wed = TodoList({"Here is", "a set", "of tasks"})</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - For this class, we could use **(CLICK)** the `list` constructor to copy the passed-in list
            - Now when we make **(CLICK)** two instances of our class by passing in the *same* list twice...
            - Modifying the `tasks` list **(CLICK)** of one instance **(CLICK)**
            - Will *not* affect the `tasks` list **(CLICK)** of the other
            - Also, this class now also accepts not just lists, but sets, generators, or *any* iterable
            - ... because the `list` constructor **(CLICK)** will loop over any iterable you give to it to make a new list
            - So for many classes that are meant to change the data that's passed-in to them, that data is often copied when a new instance is initialized
          </aside>
        </section>

        <section>
          <h1>TODO Mini summary here</h1>
          <aside class="notes" data-markdown>
            - TODO
            - Variables don't contain objects... they only contain pointers to objects
            - But objects also don't contain objects...
            - Whether we're talking about indexes and attributes, objects only contain pointers to objects
            - So when we say we've made a list-of-lists
            - We actually mean that we've made a list where each item acts as pointer to another list
            - And if ask whether our list contains a specific object...
            - We're actually asking whether our list contains a reference to an equivalent object
          </aside>
        </section>

      </section>
      <section>
        <!-- section: pointers -->
        <!-- SECTION TIME: 5 minutes -->

        <section>
          <ul style="list-style-type: none; margin-left: -2em;">
            <li class="fragment" data-fragment-index=1>
              <span class="fragment" data-fragment-index=2>‚ùå</span>
              &ldquo;variables are like buckets&rdquo;</li>
            <li class="fragment" data-fragment-index=3>
              <span class="fragment" data-fragment-index=4>‚ö†Ô∏è</span>
              &ldquo;variables are like tags&rdquo;</li>
            <li class="fragment" data-fragment-index=5>
              <span class="fragment" data-fragment-index=6>‚úÖ</span>
              &ldquo;variables are like pointers&rdquo;</li>
          </ul>
          <aside class="notes" data-markdown>
            - So, the mental model of **(CLICK)** variables as buckets that contain objects **(CLICK)** doesn't work in Python
            - Seeing variables as **(CLICK)** name tags that are attached to objects **(CLICK)** sort of works
            - But that mental model makes it seem like names are *attached* to the objects and that they live in the same place that objects live
            - That's why I prefer **(CLICK)** the mental model of variables as pointers
            - This mental model is slightly more complex but it **(CLICK)** works pretty well
            - ...
            - Now... I would like to address something that I'm pretty sure at least some of you have been thinking...
            - I am guessing that *some* of you learned about pointers in C
            - And you might be thinking...
          </aside>
        </section>

        <section>
          <h2 class="fragment" data-fragment-index=3><span class="fragment fade-out" data-fragment-index=4>well actually</span></h2>
          <p class="fragment" data-fragment-index=1>
          &ldquo;... but they're not <span class="fragment bold" data-fragment-index=6>pointers</span>&rdquo;
          </p>
          <p class="fragment" data-fragment-index=2>
          &ldquo;They're object <span class="fragment bold-current" data-fragment-index=5>references</span>&rdquo;
          </p>
          <p class="fragment" data-fragment-index=4>
          &ldquo;They're name bindings&rdquo;
          </p>
          <aside class="notes" data-markdown>
            - Python's variable are **(CLICK)** *not* pointers
            - They're **(CLICK)** "object references"
            - Well...
            - actually **(CLICK)**
            - according to the Python documentation they're **(CLICK)** "bindings"
            - ... "reference" **(CLICK)** and "refer" *do* show up in the docs a few times
            - but "pointer" **(CLICK)** is pretty much absent from the docs
          </aside>
        </section>

        <section>
          <ul style="list-style-type: none;">
            <li class="fragment" style="margin-bottom: 1em;" data-fragment-index=1>
              <span class="fragment" style="margin-right: 1em;" data-fragment-index=2>üíº</span> &ldquo;Names are bound to objects&rdquo;
            </li>
            <li class="fragment" style="margin-bottom: 1em;" data-fragment-index=3>
              <span class="fragment" style="margin-right: 1em;" data-fragment-index=4>ü§î</span> &ldquo;Variables refer to objects&rdquo;
            </li>
            <li class="fragment" style="margin-bottom: 1em;" data-fragment-index=5>
              <span class="fragment" style="margin-right: 1em;" data-fragment-index=6>üò¨</span> &ldquo;Variables point to objects&rdquo;
            </li>
          </ul>
          <p class="fragment" data-fragment-index=7><span class="fragment" data-fragment-index=8>variable</span><span style="font-size: 2em; vertical-align: middle; padding: 0 .25em;">‚û°Ô∏è</span><span class="fragment" data-fragment-index=8>object</span></p>
          <aside class="notes" data-markdown>
            - TODO consider shortening this slide somehow
            - According to the official documentation, **(CLICK)** "names are bound to objects"... that's a very **(CLICK)** technically correct phrase
            - Although most Python programmers would probably be fine with the phrase **(CLICK)** "variables refer to objects"... even though there are some long-time Python users who **(CLICK)** bristle at using the word "variable"
            - I tend to say **(CLICK)** "variables *point* to objects"... this is *definitely* a more contentious phrase than those other two **(CLICK)**
            - I *am* using an uncommon term
            - But I also find this term helpful
            - The phrase **(CLICK)** "variables point to objects" **evokes an idea** that we're all **familiar** with **(CLICK)**
            - **Brand new** programmers seem to understand this phrase well *and* developers coming from a language like C usually understand my meaning pretty quickly
            - And yes, the word "pointer" does risk painting an incorrect mental model for folks with a background in C
            - But so do many other terms...
          </aside>
        </section>

        <section>
          <table class="no-border">
            <thead>
              <tr>
                <th>Colloquial terminology</th>
                <th>Official terminology</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="fragment">truthiness</td>
                <td class="fragment">truth value testing</td>
              </tr>

              <tr>
                <td class="fragment">dunder method</td>
                <td class="fragment">special method</td>
              </tr>

              <tr>
                <td class="fragment">generator</td>
                <td class="fragment">generator iterator</td>
              </tr>

              <tr>
                <td class="fragment">generator function</td>
                <td class="fragment">generator</td>
              </tr>

            </tbody>
          </table>
          <aside class="notes" data-markdown>
            - According to Python's official documentation...
            - "truthiness" **(CLICK)** is technically called "truth value testing" **(CLICK)**
            - "dunder methods" **(CLICK)** are called "special methods" **(CLICK)**
            - "generators" **(CLICK)** are called "generator iterators" **(CLICK)**
            - to distinguish them from "generator functions" **(CLICK)** which are sometimes called "generators" **(CLICK)**
            - These are all colloquial phrases that differ from the official terminology
            - But even the official terminology...
          </aside>
        </section>

        <section>
          <table class="no-border">
            <thead>
              <tr>
                <th>Python terminology</th>
                <th>Inequivalent concept</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="fragment" data-fragment-index=1>decorator</td>
                <td class="fragment" data-fragment-index=2>decorator pattern</td>
              </tr>

              <tr>
                <td class="fragment" data-fragment-index=3>enumerate</td>
                <td class="fragment" data-fragment-index=4>enumerables</td>
              </tr>

              <tr>
                <td class="fragment" data-fragment-index=5>Python range</td>
                <td class="fragment" data-fragment-index=8>math range</td>
              </tr>

              <tr>
                <td class="fragment" data-fragment-index=7>Python sequence</td>
                <td class="fragment" data-fragment-index=6>math sequence</td>
              </tr>

            </tbody>
          </table>
          <p class="fragment" data-fragment-index=9>
          <a href="https://nedbatchelder.com/blog/202301/same_words_different_meanings.html">Same words, different meanings</a> - Ned Batchelder
          </p>
          <aside class="notes" data-markdown>
            - ...can sometimes be confusing...
            - "decorators" **(CLICK)** are not really an implementation of the "decorator pattern" **(CLICK)**
            - enumerate **(CLICK)** in Python has nothing to do with enumerables **(CLICK)**, enumerators, or enumeration in C#
            - range **(CLICK)** is for making mathematical sequences **(CLICK)**
            - sequences ... are unrelated to sequences **(CLICK)**
            - and statistical ranges **(CLICK)** are unrelated to Python's range
            - Ned Batchelder has a blog post on this idea called **(CLICK)** same words, different meanings
          </aside>
        </section>

        <section>
          <h3 class="fragment">
            Isn't this whataboutism?
          </h3>
          <h1 class="fragment" style="font-size: 7em;">
            YES
          </h1>
          <aside class="notes" data-markdown>
            - Now... am I practicing "whatabout-ism" **(CLICK)** by pointing at other naming problems to try to defend my use of the word "pointer"?
            - Maybe **(CLICK)**
            - But I do want to emphasize something...
          </aside>
        </section>

        <section>
          <h3 class="fragment" data-fragment-index=1>
            &ldquo;But they're not like pointers in C&rdquo;
          </h3>
          <table class="no-border">
            <tbody>
              <tr>
                <td class="fragment" data-fragment-index=2>reference</td>
                <td class="fragment" data-fragment-index=2>üìñ</td>
              </tr>

              <tr>
                <td class="fragment" data-fragment-index=3>binding</td>
                <td class="fragment" data-fragment-index=3>ü™¢</td>
              </tr>

              <tr>
                <td class="fragment" data-fragment-index=4>pointer</td>
                <td class="fragment" data-fragment-index=4>üëâ</td>
              </tr>

            </tbody>
          </table>

          <aside class="notes" data-markdown>
            - I have taught Python to many programmers with a strong background in C
            - And pretty much all confusion around my use of the term pointer disappears when I say
            - "But not like pointers in C" **(CLICK)**
            - Reference **(CLICK)** and binding **(CLICK)** don't paint as clear a picture as the word "pointer" **(CLICK)**
            - Pointer, point, and pointing are all very visual phrases that have a clear action behind them
            - Even though the word "pointer" has a slightly different meaning in *other* programming languages, I find it to be the most helpful term
            - Well, usually...
          </aside>
        </section>

        <section>
          <p class="fragment">
          &ldquo;What if we point another variable to the same list?&rdquo;
          </p>
          <p class="fragment">
          &ldquo;This list stores a reference to another list&rdquo;
          </p>
          <aside class="notes" data-markdown>
            - I find "pointing a variable" to be a pretty clear phrase
            - But a list "storing references" might be clearer than a list "storing pointers"
            - Whether we use the words point, reference, or bind... we're referring to the same thing
          </aside>
        </section>

        <section>
          <h3>
          <span class="fragment" data-fragment-index=3>Diff</span><span class="fragment" data-fragment-index=4>er</span><span class="fragment" data-fragment-index=5>ent</span>
          <span class="fragment" data-fragment-index=6>Names</span>
          <span class="fragment" data-fragment-index=7>For</span>
          <span class="fragment" data-fragment-index=8>The</span>
          <span class="fragment" data-fragment-index=9>Same</span>
          <span class="fragment" data-fragment-index=10>Thing</span>
          </h3>
          <div style="display: grid; grid-auto-flow: column;">
            <div style="text-align: center;" class="fragment" data-fragment-index=1>
              <img src="Ben-Gibbard.jpg" class="no-style" style="height: 300px;">
            </div>
            <div style="text-align: center;" class="fragment" data-fragment-index=2>
              <img src="Plans.png" class="no-style">
            </div>
          </div>
          <pre class="python fragment" data-fragment-index=3 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> x = y
>>> <span class="fragment" data-fragment-index=4>x is y
True</span></code></pre>
          <aside class="notes" data-markdown>
            - Ben Gibbard **(CLICK)** wrote a song **(CLICK)** about this situation...
            - Diff er ent names
            - For the sammmme thing
            - Pointer, reference, and binding are all different names for the same thing
            - But this phrase also describes how Python's variables work
            - When we assign one variable to another **(CLICK)**, we're pointing to 2 variables to the same object **(CLICK)**
            - Which makes them **different names for the same thing**
            - TODO *cue animated gif* (about 1 minute into this video https://www.youtube.com/watch?v=CvJAv82IV_g)
          </aside>
        </section>

        <section>
          <h1>TODO Mini summary here</h1>
          <aside class="notes" data-markdown>
            - TODO
            - So while "pointer" is *not* the most common term you'll hear for describing how Python's variables work
            - ... I do think it's the most *helpful* term
            - Followed closely by "reference"
          </aside>
        </section>

      </section>
      <section>
        <!-- section: language matters -->

        <section>
          <pre class="python fragment" data-fragment-index=1 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> colors = ["purple", "green", "blue"]
          </code></pre>
          <ul style="list-style-type: none; margin-left: -2em;">
            <li class="fragment" data-fragment-index=2>
              <span class="fragment" data-fragment-index=4>‚ùå</span>
              &ldquo;<code>colors</code> <strong>contains</strong> a list of strings&rdquo;</li>
            <li class="fragment" data-fragment-index=3>
              <span class="fragment" data-fragment-index=4>‚ö†Ô∏è</span>
              &ldquo;<code>colors</code> <strong>is</strong> a list of strings&rdquo;</li>
            <li class="fragment" data-fragment-index=5>
              <span class="fragment" data-fragment-index=6>‚úÖ</span>
              &ldquo;<code>colors</code> <strong>points to</strong> a list of strings&rdquo;</li>
            <li class="fragment" data-fragment-index=7>
              <span style="visibility: hidden;">‚úÖ</span>
              &ldquo;<code>colors</code> <strong>refers to</strong> a list of strings&rdquo;</li>
            <li class="fragment" data-fragment-index=9>
              <span style="visibility: hidden;">‚úÖ</span>
              &ldquo;<code>colors</code> <strong>is bound to</strong> a list of strings&rdquo;</li>
          </ul>
          <p class="fragment" style="font-size: 2em;">‚û°Ô∏è</p>
          <aside class="notes" data-markdown>
            - Over the years, I've gradually became more careful about my word choice while teaching
            - **(CLICK)** I used to use phrases like "`colors` contains a list" **(CLICK)**
            - Or... "`colors` is a list" **(CLICK)**
            - But I found that using these phrases sometimes caused confusion **(CLICK)**, especially when I tried to teach **how variables actually work** in Python
            - Now I usually use the phrase "points to" **(CLICK)**
            - colors *points to* a list
            - This phrase doesn't hint at an incorrect mental model **(CLICK)**
            - The alternative of "colors *refers to* a list" **(CLICK)** also works **(CLICK)**, though it sounds a bit vague
            - And "colors *is bound* a list", **(CLICK)** while more officially correct **(CLICK)**, sounds *weird*, especially when you're first starting out
            - And while the word "pointer" is a **technical term** that's not *usually* used in Python, it's also a term **(CLICK)** that **evokes an idea** that we're **familiar** with
          </aside>
        </section>

        <section>
          <h1 class="fragment fade-out" data-fragment-index=6>Language matters</h1>
          <pre class="python fragment" data-fragment-index=1 style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> x = [2, 1, 3]
>>> <span class="fragment" data-fragment-index=2>x.append(4)
>>> </span><span class="fragment" data-fragment-index=3>x = [7, 11, 18]
>>> </span><span class="fragment" data-fragment-index=4>y = [x, [29, 47, 76]]</span>  <span class="fragment" data-fragment-index=5># y contains x</span>
          </code></pre>
          <h1 class="fragment" data-fragment-index=6>Language is hard</h1>
          <aside class="notes" data-markdown>
            - As we talked earlier, saying **(CLICK)** we "changed" `x` doesn't convey whether we **(CLICK)** mutated an object or we **(CLICK)** changed *which* object the variable `x` points to
            - We've also touched on the fact that way we use the word "contains" in English implies something different than its meaning within Python **(CLICK)**
            - Saying `y` contains `x` **(CLICK)** is less precise than saying the object that `y` points to contains a reference to the same object that `x` points to...
            - But instead of all that, **(CLICK)** I would *prefer* to say "`y` contains `x`"
            - It's just *a lot* easier to say
          </aside>
        </section>

      </section>
      <section>
        <!-- section: mutating assignments -->
        <!-- SECTION TIME: 3 minutes -->

        <section>
          <h1 class="fragment" data-fragment-index=6>Assignments happen</h1>
          <pre class="python" style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>n = 3
>>> </span><span class="fragment" data-fragment-index=2>from math import pi
>>> </span><span class="fragment" data-fragment-index=3>for n in range(5):
...     ...
...
>>> </span><span class="fragment" data-fragment-index=4>n
4
>>> </span><span class="fragment" data-fragment-index=5>def pi(): return 3.14159
...
>>> </span><span class="fragment" data-fragment-index=5>class pi: pass
...</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - So assignments change which object a variable points to
            - This **(CLICK)** is what an assignment looks like
            - But this isn't the *only* way an assignment might look
            - Import statements **(CLICK)** also perform an assignment
            - And so does each iteration **(CLICK)** of a `for` loop **(CLICK)**
            - And so do function definitions **(CLICK)** and class definitions **(CLICK)**
            - Anything that updates what a name points **(CLICK)** to performs some sort of assignment
          </aside>
        </section>

        <section>
          <h3 class="fragment" data-fragment-index=2>Augmented Assignments</h3>
          <p class="fragment" data-fragment-index=1><code>+=</code>, <code>-=</code>, <code>*=</code>, etc.</p>
          <p class="fragment" data-fragment-index=3>Are these assignments?</p>
          <p class="fragment" data-fragment-index=4>Are these mutations?</p>
          <h1 class="fragment" data-fragment-index=5>YES</h1>
          <aside class="notes" data-markdown>
            - But what about `+=` and `-=`? **(CLICK)**
            - These are often called augmented assignments... **(CLICK)**
            - But do these perform an assignment? **(CLICK)**
            - Or do they mutate an object? **(CLICK)**
            - It depends. **(CLICK)**
          </aside>
        </section>

        <section>
          <h2 class="fragment" data-fragment-index=7>In-place addition</h2>
          <pre class="python" style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>a = [2, 1, 3]
>>> </span><span class="fragment" data-fragment-index=2>b = a
>>> </span><span class="fragment" data-fragment-index=3>b += [4, 7, 11]
>>> </span><span class="fragment" data-fragment-index=4>b
[2, 1, 3, 4, 7, 11]
>>> <span class="fragment" data-fragment-index=5>a</span><span class="fragment" data-fragment-index=6>
[2, 1, 3, 4, 7, 11]</span></code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a variable `a` **(click)** and variable `b` **(click)** which both point to the same list
            - If we use the `+=` operator **(click)** to add more elements to `b` **(click)**
            - ... what will happen to `a`? **(click)**
            - Does `a` change or is it still the same?
            - When we look at `a`, we'll see that it *changed* **(click)**
            - Augmented assignments actually perform a mutation
            - So when we use the `+=` operator on a list, we're not making a new list... we're *mutating* our existing list
            - That's why using `+=` is often called an in-place addition **(click)**
            - An in-place operation is one that's *meant* to mutate the object
          </aside>
        </section>

        <section>
          <pre class="python" style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>name = "North Bay Python"
>>> </span><span class="fragment" data-fragment-index=2>name += " 2025"  <span class="fragment" data-fragment-index=4># name = name + "2025"</span>
>>> </span><span class="fragment" data-fragment-index=3>name
'North Bay Python</span></code></pre>
          <aside class="notes" data-markdown>
            - But wait... doesn't `+=` work on immutable objects, like strings? **(click)**
            - Strings are immutable...
            - Which means they *can't* be changed
            - But they work with `+=`... **(click)**
            - If `+=` is an in-place addition, how does it work on strings? **(click)**
            - Well, augmented assignments *can* perform a mutation, but they don't *have* to... it's up to the object that they're operating on
            - If an object doesn't specially handle `+=` then Python **(click)** falls back to using `+` and a regular assignment
          </aside>
        </section>

        <section>
          <h2 class="fragment">Assignments that mutate</h2>
            <pre class="python fragment"><code data-trim data-noescape>
>>> <span class="fragment">some_object.attribute = 4</span>
>>> <span class="fragment">numbers[0] = 8</span>
            </code></pre>
          <aside class="notes" data-markdown>
            - The distinction between assignments and mutations isn't always very clear... augmented assignments do perform an assignment, but they can also mutate. **(CLICK)**
            - But this assignment-mutation duality comes up in other ways too **(CLICK)**
            - Assigning to an attribute *is* an assignment **(CLICK)**, but it mutates the object that the attribute lives on
            - And assigning to a list index mutates the list **(CLICK)**
            - These *are* assignment statements, but these *do* mutate an object... modifying where an attribute points to mutates the object that the attribute lives on.
          </aside>
        </section>

        <section>
          <h1>TODO keeping it all straight</h1>
          <aside class="notes" data-markdown>
            - TODO when our assignment target is an index, a key, or an attribute, we are changing which object a pointer is pointing to...
            - But that pointer, or, if you prefer, that object reference, lives within an object... which means we are *also* mutating that object
            - Objects can contain references to other objects. When you change those references through an assignment, that requires mutating that larger object
            - Is this a bit confusing? Yes... if you think about it too hard
            - But most of the time, not really...
            - Though saying "this is an assignment that mutates" does sound like a gotcha
            - Speaking of gotchas... let's talk about mutability
          </aside>
        </section>

      </section>
      <section>
        <!-- section: mutable tuples -->
        <!-- SECTION TIME: 2 minutes -->

        <section>
          <h1 class="fragment data-fragment-index=3">Mutating tuples</h1>
          <h2 data-fragment-index=1>Tuples cannot be mutated<span class="fragment" data-fragment-index=2>*</span></h2>
          <p class="fragment" data-fragment-index=2>* For some definitions of "mutate"</p>
          <aside class="notes" data-markdown>
            - Tuples are immutable
            - ... **(click)**
            - Sort of
            - **(click)** It is sometimes possible to change the value of a tuple... depending on what we mean by "change" and what we mean by "value"
          </aside>
        </section>

        <section>
          <h2>Tuples can contain lists</h2>
          <pre class="python" style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>result = (True, [2, 1, 3])
>>> </span><span class="fragment" data-fragment-index=2>result[1].append(4)
>>> </span><span class="fragment" data-fragment-index=3>result
(True, [2, 1, 3, 4])</span></code></pre>
          <aside class="notes" data-markdown>
            - In Python, **(click)** you can put a list inside of a tuple
            - What would happen if we try to *change* that list **(click)**, by appending a new item to it?
            - Is that allowed?
            - It is **(click)**
            - But aren't tuples immutable...
            - And yet, **(click)** it seems like our tuple has changed
            - Has it?
          </aside>
        </section>

        <section>
          <h2 class="fragment" data-fragment-index=9>Immutability is fuzzy</h2>
          <pre class="python" style="width: 60%;"><code data-trim data-noescape>
>>> <span class="fragment" class="fragment" data-fragment-index=1>result = (True, [2, 1, 3])
>>> </span><span class="fragment" data-fragment-index=2>result2 = (True, [2, 1, 3])
>>> </span><span class="fragment" data-fragment-index=3>result == result2</span><span class="fragment" data-fragment-index=4>
True
>>> </span><span class="fragment" data-fragment-index=5>result[1].append(4)
>>> </span><span class="fragment" data-fragment-index=6>result
(True, [2, 1, 3, 4])
>>> </span><span class="fragment" data-fragment-index=7>result == result2</span><span class="fragment" data-fragment-index=8>
False</span></code></pre>
          <aside class="notes" data-markdown>
            - If we make **(click)** 2 tuples **(click)** that each contain lists and the items in these tuples are all equal...
            - Those tuples **(click)** will also be equal **(click)**
            - If we change the list **(click)** that's inside one of these tuples
            - We'll change the value of the tuple **(click)**
            - Meaning, if we compare **(click)** these 2 tuples again, they won't be equal anymore **(click)**
            - How and *why* is this possible?
            - Tuples *are* immutable... **(click)** sort of
            - Any immutable object that can store a reference to a mutable object can potentially have its value change
          </aside>
        </section>

        <script type="text/html">
        <section data-transition="slide-in none-out">
          <h2 class="fragment" data-fragment-index=1>Pointers</h2>
          <div style="display: grid; grid-auto-flow: column;">
            <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=4>first = []
>>> </span><span class="fragment" data-fragment-index=6>second = first
>>> <span class="fragment" data-fragment-index=8>second.append(9)
>>> </span><span class="fragment" data-fragment-index=10>second
[9]
>>> </span><span class="fragment" data-fragment-index=11>first
[9]
>>> </span><span style="visibility: hidden;">rows = [second]
>>> </span>
            </code></pre>
            <div>
<svg xmlns="http://www.w3.org/2000/svg" width="600" height="299" viewBox="0 0 421 251">
  <!-- Object Land container -->
  <g>
    <path d="M 200 23 L 200 0 L 450 0 L 450 23" fill="#dae8fc" stroke="#6c8ebf" stroke-miterlimit="10"/>
    <path d="M 200 23 L 200 250 L 450 250 L 450 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
    <path d="M 200 23 L 450 23" fill="none" stroke="#6c8ebf" stroke-miterlimit="10"/>
    <text x="324.5" y="15" fill="#000" text-anchor="middle" font-size="12px">Object Land</text>
  </g>
  
  <!-- Variable Land container -->
  <g>
    <path d="M 0 23 L 0 0 L 160 0 L 160 23" fill="#e1d5e7" stroke="#9673a6" stroke-miterlimit="10"/>
    <path d="M 0 23 L 0 250 L 160 250 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
    <path d="M 0 23 L 160 23" fill="none" stroke="#9673a6" stroke-miterlimit="10"/>
    <text x="79.5" y="15" fill="#000" text-anchor="middle" font-size="13px">Variable Land</text>
  </g>
  
  <!-- result variable -->
  <rect x="20" y="180" width="120" height="50" fill="#e1d5e7" stroke="#9673a6"/>
  <text x="79" y="210" fill="#000" font-size="13px" text-anchor="middle">result</text>
  
  <!-- Arrow from result to tuple -->
  <path d="M 140 205 L 273.63 205" fill="none" stroke="#000" stroke-miterlimit="10"/>
  <path d="M 278.88 205 L 271.88 208.5 L 273.63 205 L 271.88 201.5 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
   
  <!-- List at bottom of diagram -->
  <path d="M 325 110 L 302 110 L 302 160 L 325 160" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 325 110 L 422 110 L 422 160 L 325 160" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 325 110 L 325 160" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <text x="140" y="451" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,73,205)">list</text>
  
  <!-- Boolean object (True) at top left -->
  <path d="M 233 110 L 210 110 L 210 160 L 233 160" fill="#fff2cc" stroke="#d6b656" stroke-miterlimit="10"/>
  <path d="M 233 110 L 290 110 L 290 160 L 233 160" fill="none" stroke="#d6b656" stroke-miterlimit="10"/>
  <path d="M 233 110 L 233 160" fill="none" stroke="#d6b656" stroke-miterlimit="10"/>
  <text x="221" y="135" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,221,135)">bool</text>
  <text x="260" y="140" fill="#000" font-size="13px" text-anchor="middle">True</text>
  
  <!-- Integer objects at top -->
  <path d="M 245 35 L 222 35 L 222 85 L 245 85" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 245 35 L 282 35 L 282 85 L 245 85" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 245 35 L 245 85" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <text x="233" y="60" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,233,60)">int</text>
  <text x="263" y="65" fill="#000" font-size="13px" text-anchor="middle">2</text>
  
  <path d="M 325 35 L 302 35 L 302 85 L 325 85" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 325 35 L 362 35 L 362 85 L 325 85" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 325 35 L 325 85" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <text x="313" y="60" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,313,60)">int</text>
  <text x="343" y="65" fill="#000" font-size="13px" text-anchor="middle">1</text>
  
  <path d="M 400 35 L 377 35 L 377 85 L 400 85" fill="#d5e8d4" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 400 35 L 437 35 L 437 85 L 400 85" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <path d="M 400 35 L 400 85" fill="none" stroke="#82b366" stroke-miterlimit="10"/>
  <text x="388" y="60" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,388,60)">int</text>
  <text x="418" y="65" fill="#000" font-size="13px" text-anchor="middle">3</text>
  
  <!-- tuple object -->
  <path d="M 303 180 L 280 180 L 280 230 L 303 230" fill="#f8cecc" stroke="#b85450" stroke-miterlimit="10"/>
  <path d="M 303 180 L 390 180 L 390 230 L 303 230" fill="none" stroke="#b85450" stroke-miterlimit="10"/>
  <path d="M 303 180 L 303 230" fill="none" stroke="#b85450" stroke-miterlimit="10"/>
  <text x="286" y="212" fill="#000" text-anchor="middle" font-size="13px" transform="rotate(-90,286,205)">tuple</text>
  
  <!-- tuple indices -->
  <rect x="315" y="195" width="25" height="20" fill="none" stroke="#000"/>
  <text x="327" y="210" fill="#00f" font-size="13px" text-anchor="middle">0</text>
  
  <rect x="350" y="195" width="25" height="20" fill="none" stroke="#000"/>
  <text x="362" y="210" fill="#00f" font-size="13px" text-anchor="middle">1</text>
  
  <!-- list object at bottom right -->
  <path d="M 320 70 L 320 110" fill="none" stroke="#000" stroke-miterlimit="10"/>
  <path d="M 320 110 L 320 110" fill="#000" stroke="#000" stroke-miterlimit="10"/>
  
  <!-- Arrows from tuple indices -->
  <path d="M 322.5 195 L 250 160" fill="none" stroke="#000" stroke-miterlimit="10"/>
  <path d="M 245 156 L 252 157 L 250 160 L 253 163 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
   
  <!-- Arrow from tuple index 1 to list -->
  <path d="M 357.5 195 L 357.91 166.37" fill="none" stroke="#000" stroke-miterlimit="10"/>
  <path d="M 357.98 161.12 L 361.38 168.17 L 357.91 166.37 L 354.38 168.07 Z" fill="#000" stroke="#000" stroke-miterlimit="10"/>
</svg>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - TODO fix this broken diagram
          </aside>
        </section>
        </script>

      </section>
      <section>
        <!-- section: conclusion -->

        <section>
          <p class="fragment">Variables store object references</p>
          <p class="fragment">Objects store object references</p>
          <p class="fragment">TODO equality versus identity...</p>
          <p class="fragment">
          Related resources:<br>
          <a href="https://nedbatchelder.com/text/names.html">Facts and myths about Python names and values</a><br>
          <a href="https://pyvideo.org/pyohio-2011/pyohio-2011-names-objects-and-plummeting-from.html">Names, Objects, and Plummeting From The Cliff</a><br>
          </p>
          <aside class="notes" data-markdown>
            - So variables in Python do *not* contain objects
            - Variables only store *references* to objects
            - Also, objects can store references to other objects
            - But just like variables, objects can't *really* contain other objects
            - Objects can only contain references to objects
            - So the term "containment" is a little bit confusing, but words are hard and that happens to be the term we all use
            - The word "change" can also be quite confusing, especially when it's unclear whether we're talking about an assignment or a mutation
            - Also, immutable objects that contain references to *mutable* objects are only *kind of* immutable

            - That's pretty much everything we've discussed
            - If you'd like to dive deeper into this topic, visit this URL for more related resources on...
            - Various reference-based gotchas
            - Some thoughts on gotchas related to mutable default arguments
            - And a *very weird* Python oddity that lives at the intersection of augmented assignments and immutability
            - I'd also like to specifically thank two Python community members for their talks on this topic some years ago...
              - Brandon Rhodes' talk "Names, Objects, and Plummeting From The Cliff" does a great job of using an extended metaphor to visually explain how memory management works with Python's names and values
              - And Ned Batchelder's talk "Python names and values" does a great job of dispelling myths and demonstrating facts about Python's objects and variables

            - TODO move these bullet points on containment to the end of the section on containment
            - The terms "contain" and "containment" are about references, not about objects
            - Although, really containment is about equality, not identity
            - Identity asks whether two references point to the same object
            - But equality compares the "value" of two or more objects
            - What exactly the "value" of an objects? That's up to objects being compared.
            - The "in" operator typically checks for equality, meaning "does this data structure contain an object that is equal to this one"
          </aside>
        </section>

        <section data-transition="none">
          <pre class="python" style="width: 45%;"><code data-trim data-noescape>
>>> x = []
>>> <span class="fragment">x.append(x)
>>> </span><span class="fragment">x</span><span class="fragment">
[[...]]</span><span style="opacity: 0;">
>>> x in x
True
>>> x[0] is x
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - So given what we've learned about how variables and objects work in Python...
            - If we take an empty list, called `x`
            - And we call `x.append(x)` **(CLICK)**, what do you think this might do?
            - ...
            - After this, would `x` be...
            - **(CLICK)** an **empty list**?
            - A list with **an empty list inside it**?
            - Something else?
            - As you *might* have guessed **(CLICK)**... this makes a list that contains itself...
          </aside>
        </section>

        <section data-background-image="ouroboros-background.png" data-transition="none">
          <pre class="python" style="width: 45%;"><code data-trim data-noescape>
>>> x = []
>>> x.append(x)
>>> x
<span class="fragment bold" data-fragment-index=3>[[...]]</span>
<span class="fragment" data-fragment-index=1>>>> x in x
True</span>
<span class="fragment" data-fragment-index=2>>>> x[0] is x
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - ... sort of **(CLICK)**
            - Lists don't *actually* contain objects, so a list can't *really* contain itself
            - But it *can* contain a **reference** to itself **(CLICK)**
            - Python is smart enough to represent this list using 3 dots **(CLICK)** because otherwise it would need to show an **infinite number** of **square brackets**
            - We have just made an infinitely recursive data structure
            - This is possible because objects in Python don't contain other objects
            - Both variables and objects can only contain *references* to objects
          </aside>
        </section>

      </section>
      <section>
        <!-- section: why -->
        <!-- SECTION TIME: 2 minutes -->

        <section>
          <h1 class="fragment current-visible">But... why?</h1>
          <h2 class="fragment">Imagine an alternative...</h2>
          <p class="fragment">Would every assignment statement make a copy?</p>
          <p class="fragment">Would storing a reference to an object ever be possible?</p>
          <p class="fragment" style="margin-left: 1em;">"reference assignments" and "copying assignments" <span class="fragment">üò¨</span></p>
          <aside class="notes" data-markdown>
            - Before we wrap up... I do want to address a common question...
            - *Why* does Python work this way? **(CLICK)**
            - Wouldn't it be easier if variables and data structures contained objects and assignments copied the objects we were assigning to
            - Well... **(CLICK)**
            - Imagine if every assignment made a copy of an object **(CLICK)**
            - Copying objects all the time times time and it takes memory
            - But also, how would we ever model parent-child relationships **(CLICK)** or any kind of relationship that involved storing a *reference* to an object instead of a copy of an object?
            - Would we need to make a distinction **(CLICK)** between assignments that copied and assignments that made a reference...
            - Other programming languages have done that before...
            - And... **(CLICK)** that requires adding another layer of complexity
            - Python's way isn't necessarily the *right* way... but *most days* I really appreciate the trade-offs that Python made around this topic
          </aside>
        </section>

        <section>
          <h1 class="fragment" data-fragment-index=2>This thing is bad</h1>
          <h2 class="fragment" data-fragment-index=3>Compared to what alternative?</h2>
          <h3 class="fragment" data-fragment-index=1>Everything is a trade-off</h3>
          <aside class="notes" data-markdown>
            - Python's separation between variables and objects can *definitely* be confusing, but it's a pretty decent approach to a hard problem
            - Every decision **(CLICK)** has trade-offs and *everything* is relative to its possible alternatives
            - Whether we're talking about a software feature or about politics, when we say **(CLICK)** "This thing is bad", we should *always* ask ourselves **(CLICK)** "compared to what alternative?"
            - TODO final sentence to leave them with
          </aside>
        </section>

      </section>
      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2 style="margin-top: 0.5em;">Resources &nbsp; <!-- TODO <a href="https://trey.io/variables-and-objects">trey.io/variables-and-objects</a>--> TODO</h2>
        <h3 style="margin-top: 1.5em;">
          Thank you<br>
        </h3>
        <div style="margin-top: 2.5em;">
          <p style="float: left; margin-right: 2em;">
            <strong>Trey Hunner</strong><br>
            <small>Python Team Trainer<br>
              <strong>trey@PythonMorsels.com</strong></small>
          </p>
          <p style="float: left;">
          <a href="http://truthful.technology"><img src="horizontal-training-logo.svg" class="no-style logo"></a>
          <a href="http://pythonmorsels.com"><img src="horizontal-morsels-logo.svg" class="no-style logo"></a>
          </p>
          <div style="clear: both;"></div>
        </div>
        <aside class="notes" data-markdown>
          - ...
          - Thank you
        </aside>
      </section>

      </section>
      <section>
        <!-- section: TODO cutting room floor -->

        <section data-transition="none-in none-out">
          <pre class="python"><code data-trim data-noescape>
>>> class TodoList:
...     def __init__(self, <span class="fragment bold-current">tasks=[]</span>):
...         <span class="fragment bold-current">self.tasks = tasks</span>
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> <span class="fragment">mon = TodoList()
>>> </span><span class="fragment">mon.add_task("Work on Python exercise")
>>> </span><span class="fragment">mon.tasks
['Work on Python exercise']
>>> </span><span class="fragment">tue = TodoList()
>>> </span><span class="fragment">tue.tasks
['Work on Python exercise']</span>
<br>
          </code></pre>
          <aside class="notes" data-markdown>
            - In fact, this fact is part of the reason that mutable default arguments are an issue in Python **(CLICK)**
            - Note that we're **(CLICK)** storing the `tasks` argument for our initializer as an attribute
            - Let's say we **(CLICK)** make an instance of this class with the default empty `tasks` list
            - And then **(CLICK)** mutate the `tasks` attribute for this class instance **(CLICK)**
            - If we make a **(CLICK)** second instance of this class
            - That second instance will have **(CLICK)** the same `tasks` list as the first
            - Python evaluates default argument values only one time: when a function is defined
            - Mutable default argument values can result in gotchas, particularly in class initializers that store a passed-in argument as an attribute, like this one
            - ...
            - But, as we saw a moment ago, this is *also* potentially an issue for mutable arguments *in general*
            - So while mutable default arguments *are* a gotcha, the most common time that they're an issue is when they're layered on top of another potential gotcha
          </aside>
        </section>

        <section data-transition="none-in none-out">
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">class TodoList:
...     def __init__(self, tasks=()):
...         self.tasks = <span class="fragment bold-current">list(tasks)</span>
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> </span><span class="fragment">mon = TodoList()
>>> </span><span class="fragment">mon.add_task("Work on Python exercise")
>>> </span><span class="fragment">mon.tasks
['Work on Python exercise']
>>> </span><span class="fragment">tue = TodoList()
>>> </span><span class="fragment">tue.tasks
[]
>>> </span><span class="fragment">wed = TodoList({"Here is", "a set", "of tasks"})</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO fix transitions and such
            - This might seem like a *really* big issue...
            - But this issue has a pretty common workaround
            - If your class accepts a list, you could use **(CLICK)** the `list` constructor to copy that argument
            - Now when we make **(CLICK)** two instances of our class
            - Modifying the `tasks` list **(CLICK)** of one
            - Will not affect the `tasks` list **(CLICK)** of the other
            - Also, this class now also accepts not just lists, but sets, generators, or *any* iterable
            - ... because the `list` constructor **(CLICK)** will loop over any iterable you give to it to make a new list
            - For many classes that are meant to operate on the data that's passed-in to them, that data is copied when a new instance is initialized
          </aside>
        </section>

        <section data-transition="none-in none-out">
          <pre class="python"><code data-trim data-noescape>
>>> class TodoList:
...     def __init__(self, <span class="fragment bold">tasks=()</span>):
...         self.tasks = list(tasks)
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> mon = TodoList()
>>> mon.add_task("Work on Python exercise")
>>> mon.tasks
['Work on Python exercise']
>>> tue = TodoList()
>>> tue.tasks
[]
>>> wed = TodoList({"Here is", "a set", "of tasks"})
          </code></pre>
          <aside class="notes" data-markdown>
            - You may have noticed that we *also* **(CLICK)** changed our default argument value to be *immutable*
            - it's a tuple instead of a list now
            - We didn't necessarily need to do that...
          </aside>
        </section>

        <section data-transition="none-in none-out">
          <pre class="python"><code data-trim data-noescape>
>>> class TodoList:
...     def __init__(self, <span style="font-weight: bold;">tasks=[]</span>):
...         self.tasks = list(tasks)
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> mon = TodoList()
>>> mon.add_task("Work on Python exercise")
>>> mon.tasks
['Work on Python exercise']
>>> tue = TodoList()
>>> tue.tasks
[]
>>> wed = TodoList({"Here is", "a set", "of tasks"})
          </code></pre>
          <aside class="notes" data-markdown>
            - We could have used a list here and everything would work just as expected
            - Whatever iterable we're using as our default value and whatever iterable we pass in to this initializer method will be copied into a new list
            - But mutable default values are seen as an issue by many linters *and* they *look* like a bug waiting to happen...
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <pre class="python"><code data-trim data-noescape>
>>> class TodoList:
...     def __init__(self, <span style="font-weight: bold;">tasks=()</span>):
...         self.tasks = list(tasks)
... 
...     def add_task(self, task):
...         self.tasks.append(task)
...
>>> mon = TodoList()
>>> mon.add_task("Work on Python exercise")
>>> mon.tasks
['Work on Python exercise']
>>> tue = TodoList()
>>> tue.tasks
[]
>>> wed = TodoList({"Here is", "a set", "of tasks"})
          </code></pre>
          <aside class="notes" data-markdown>
            - So using a tuple instead of a list might be a good idea regardless
          </aside>
        </section>

        <section>
          <h1 class="fragment">Word Choice Matters</h1>
          <aside class="notes" data-markdown>
            - Your choice of words matters **(CLICK)**
            - The words we use have **implied mental models** beneath them
            - It's probably a mental model that's **vague** and **based on connotation**... but a it *is* a mental model
            - So the language we use *can* deceive us when it hints at an incorrect mental model
            - But sometimes exact precision isn't worth the complexity that it adds to our language
          </aside>
        </section>

        <section>
          <h1 class="fragment">Unhashable tuples</h1>
          <pre class="python" style="width: 60%; margin: 1em auto;"><code data-trim data-noescape>
>>> p = (3, 4)
>>> points = {p}
>>> points
{(3, 4)}
>>> result = (True, [])
>>> results = {result}
Traceback (most recent call last):
  File "&lt;python-input-5>", line 1, in &lt;module>
    results = {result}
              ^^^^^^^^
TypeError: unhashable type: 'list'
>>> hash([])
Traceback (most recent call last):
  File "&lt;python-input-6>", line 1, in &lt;module>
    hash([])
    ~~~~^^^^
TypeError: unhashable type: 'list'
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO fix all this...

            - Here is an immutable tuple
            - This tuple can be used in a set because it's both immutable and hashable
            - Here is a somewhat immutable tuple
            - This tuple is unhashable, so it cannot be used in a set
            - Individual tuples are only hashable if all of the items they contain are hashable
            - Lists, and most other mutable objects, are *not* hashable
            - Typically if the value of an object can change, meaning it could be become unequal to an object that it *was* equal to previously... then that object should not be hashable
            - A tuple can never change *which* objects it has within, but it's possible that the objects it contains could be mutated
            - So because tuples can contain references to mutable objects it *is* possible to make a tuple is *sort of* mutable


            - Tuples
            - Immutability is a fuzzy concept... some tuples aren't quite immutable
                - Specifically, if a tuple contains object that isn't hashable, then it isn't hashable
                - What does hashable mean? Well, the hash of an object is *sort of* a representation of the *value* of that object.
                - Objects that are hashable must *never* change their hash value over the lifetime of that object... and equality and hashable should correspond to each other, meaning if two objects hashable objects are equal they should have the hash value.  So a hashable object can never change its sense of equality. That's why some tuples are unhashable.

          </aside>
        </section>

        <section>
          <h3>
          <span class="fragment">Diff</span><span class="fragment">er</span><span class="fragment">ent</span>
          <span class="fragment">Names</span>
          <span class="fragment">For</span>
          <span class="fragment">The</span>
          <span class="fragment">Same</span>
          <span class="fragment">Thing</span>
          </h3>
          <div style="display: grid; grid-auto-flow: column;">
            <div style="text-align: center;">
              <img src="Ben-Gibbard.jpg" class="fragment no-style" style="height: 300px;">
            </div>
            <div style="text-align: center;">
              <img src="Plans.png" class="fragment no-style">
            </div>
          </div>
          <aside class="notes" data-markdown>
            - If you find yourself struggling to remember that in Python, you can point multiple variables to the same object
          - 
          - And when a list contains list it's really just containing a pointer to that list
          - Inspired by the fact that Python's object model allows one object to be referred by multiple variables...
          - Ben Gibbard **(click)** of Death Cab For Cutie **(click)** actually wrong a song about how Python's object model works
          - TODO *cue animated gif*
          (about 1 minute into this video https://www.youtube.com/watch?v=CvJAv82IV_g)
          - Well... maybe
          - I actually don't know if that's what the song is *actually* about, but that's what *I* think it's about
          </aside>
        </section>

        <section data-transition="none">
          <h2>Gotchas with Variables and Values</h2>
          <aside class="notes" data-markdown>
            - 
          </aside>
        </section>

        <section data-transition="none">
          <h2>Self-concatenation</h2>
          <pre class="python"><code data-trim data-noescape>
>>> rows = [[0] * 3] * 3
>>> rows
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
>>> rows[1][1] = 1
>>> rows
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
          </code></pre>
          <aside class="notes" data-markdown>
            - This fact that objects don't contain objects is the reason behind a number of Python oddities
            - If we try to use self-concatenation to make a list-of-lists...
            - And then we change the middle element of the middle list...
            - We'll see that the middle element of *all* the lists changes
            - Because self-concatenation doesn't copy anything... it just refers to the same object multiple times
            - So using it with mutable objects doesn't work well
          </aside>
        </section>

        <section>
          <h1 class="fragment">Augmented assignments in tuples</h1>
          <pre class="python fragment" data-fragment-index=1 style="margin: 1em auto;"><code data-trim data-noescape>
>>> result = (True, [2, 1, 3, 4])
>>> result[1] += [7, 11, 18]
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
    result[1] += [7, 11, 18]
    ~~~~~~^^^
TypeError: 'tuple' object does not support item assignment
>>> result
(True, [2, 1, 3, 4, 7, 11, 18])
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
            - So what would this in-place addition do?
            - We're trying to mutate a list that's contained within a tuple by using the `+=` operator
            - Would this mutate the list?
            - Or would it give us error?
            - TODO
          </aside>
        </section>

        <section>
          <blockquote style="box-shadow: none; font-size: 1.5em;">
            ‚ÄúAll <span class="fragment bold" data-fragment-index=1>models</span> are wrong,<br>but some <span class="fragment bold" data-fragment-index=1>models</span> are useful.‚Äù
            <nobr>&mdash; George E. P. Box</nobr>
          </blockquote>
          <aside class="notes" data-markdown>
            - Mental models are *wonderful* for **anchoring** *your understanding* of **some small piece** of the world within a **metaphor**.
            - But a mental model is **just that**... a *model* **(CLICK)**
            - All models have their **boundaries**
          </aside>
        </section>

        <section>
          <h1 class="fragment">Economics</h1>
          <h1 class="fragment">Immigration</h1>
          <h1 class="fragment">Education</h1>
          <aside class="notes" data-markdown>
            - What do your mental models look like?
            - What does your mental model of **(CLICK)** economics look like?
            - What about immigration? **(CLICK)**
            - Education? **(CLICK)**
            - You vote based on all of these issues. But you probably have a pretty *fuzzy* mental model of them.
            - I know I do.
            - How might you **inspect** your mental models to see what's **missing** or **incomplete**?
            - And which of your **assumptions and beliefs** could you **revisit**?
          </aside>
        </section>

        <section>
          <blockquote style="box-shadow: none; font-size: 1.5em; margin-top: -1em;">
            ‚ÄúAll models are wrong,<br>but some models are useful.‚Äù
            <nobr>&mdash; George E. P. Box</nobr>
          </blockquote>
          <blockquote style="box-shadow: none; font-size: 1.3em; margin-top: 1em;" class="fragment">
            ‚ÄúEach model is more useful for some purposes than others‚Äù
            <nobr>&mdash; me</nobr>
          </blockquote>
          <aside class="notes" data-markdown>
            - Accept that your models are **flawed**
            - But also acknowledge **(CLICK)** that incomplete models can *still* be **useful**
            - Our models of the world are always a **work-in-progress**
            - When a more useful model comes along, we should **try it out**
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
      if (window.self !== window.top) {
        document.body.className += " notes";
      }
    </script>
  </body>
</html>
